# Глава 9. Задачи за шампиони (част II)

В тази глава ще разгледаме още две задачи, които причисляваме към категорията "за шампиони" т.е. по-трудни от стандартните задачи за това ниво. Хубаво да се отбележи, че задачите представени тук могат да се решат по-лесно с допълнителни знания за езика C# (методи, масиви, колекции, рекурсия и т.н.), но всяко едно решениe, което представяме тук, ще използва единствено материал покрит в тази книга.

## Задача 1 - Passion Days

Оригинално състезание: [https://judge.softuni.bg/Contests/Practice/Index/163#3](https://judge.softuni.bg/Contests/Practice/Index/163#3)

Лина има истинска страст за пазаруване. Когато тя има малко пари, веднага отива в първия МОЛ и се опитва да изхарчи възможно най-много за дрехи, чанти и обувки. Но любимото и нещо са зимните намаления. Нашата задача е да анализираме странното и поведение и да изчислим покупките които Лина прави, когато влезе в МОЛ-а, както и парите които и остават, когато приключи с пазаруването си.
На първия ред, от входа, ще бъде подадена сумата която Лина има преди да започне да пазарува. След това при получаване командата **"mall.Enter"**, Лина влиза в МОЛ-а и започва да пазарува, докато не получи командата **"mall.Exit"**. Когато Лина започне да пазарува на всяка линия от входа ще получите стрингове, които представляват действия, които Лина изпълнява. Всеки символ в стринга представлява покупка или друго действие.
Стринговите команди могат да съдържат само символи от ASCII таблицата. ASCII кода на всеки знак има връзка с това колко Лина трябва да плати за всяка стока. Интерпретирайте символите по следния начин:
- Ако символа е **главна буква**, Лина получава 50% намаление, което означава че трябва да намалите парите, които тя има, с 50% от цифровата репрезентация ASCII символа.
- Ако символа е **малка буква**, Лина получава 70% намаление, което означава че трябва да намалите парите, които тя има, с 30% от цифровата репрезентация ASCII символа.
- Ако символа е **"%"**, Лина правия покупка която намалява парите и на половина.
- Ако символа е **"*"**, Лина изтегля пари от дебитната си карта и добавя към наличните си средства 10 лева.
- Ако символа е **различен от упоменатите горе**, Лина просто прави покупка без намаления и в такъв случай просто извадете стойността на ASCII символа от наличните и средства.
Ако някоя от стойностите на покупките е по-голяма от текущите налични средства, Лина **НЕ** прави покупката. Парите на Лина не могат да бъдат по-малко от 0.

Пазаруването свършва когато се получи командата **"mall.Exit"**. Когато това стане трябва да принтирате броя на извършени покупки и парите, които Лина има останали. Моля вижте секциите Изход и Примерен вход и изход за повече яснота.

### Входни данни

Входните данни трябва да се четата от конзолата. 
На първия ред, от входа, ще бъде подадена сумата която Лина има преди да започне да пазарува. Всеки следващ ред ще има определена команда. Когато получите командата **"mall.Enter"** на всеки следващ ред ще получите стрингове съдържащи информация относно покупките/действията, които Лина иска да направи. Тези стрингове ще продължат да бъдат подаване докато не се получи командата **"mall.Exit"**.
Винаги ще се подава само една команда **"mall.Enter"** и само една команда **"mall.Exit"**


### Изходни данни

Изходните данни трябва да се принтират на конзолата.
Когато пазаруването приключи на конзолата трябва да се принтира изход в зависимост от какви покупки са били направени.
- Ако не са били направени никакви покупки – "**No purchases. Money left: {останали пари} lv.**"
- Ако е направена поне една покупка - "**{брой покупки} purchases. Money left: {останали пари} lv.**"

Парите трябва да се принтират с точност 2 символа след десетичната запетая.

### Ограничения

- Парите са число с плаваща запетая в интервала - [0 - 7.9 x 1028].
- Броя на стрингове между "mall.Enter" и "mall.Enter" ще в интервала – [1-20].
- Броя на символи във всеки стринг, който представлява команда, ще е в интервала – [1-20]
- Позволено време за изпълнение: 0.1 секунди.
- Позволена памет – 16 MB.

### Примерен вход и изход

| Вход | Изход | Коментари |
|------|-------|-----------|
| 110<br>mall.Enter<br>d<br>mall.Exit | 1 purchases. Money left: 80.00 lv. | ‘d’ има ASCII код 100.<br>‘d’ e mалка буква е и за това Лина получава 70% отстъпка.<br>100% – 70% = 30.<br>110 – 30 = 80 лв. |

| Вход | Изход |
|------|-------|
| 110<br>mall.Enter<br>%<br>mall.Exit|1 purchases. Money left: 55.00 lv.|

| Вход | Изход |
|------|-------|
|100<br>mall.Enter<br>Ab<br>**<br>mall.Exit|2 purchases. Money left: 58.10 lv.|

### Насоки и подсказки

Ще разделим решението на задачата на три основни части - Обработка на входа, Алгоритъм на решаване, Форматиране на изхода. Нека разгледаме всяка една част в детайли.

#### Обработване на входа

Входа за нашата задача се състои от няколко компонента:
- на първия ред имаме всички пари, с които Лина ще разполага за пазаруването
- на всеки следващ ред ще имаме някакъв вид команда.

Първата част от прочитането е тривиална:

![](assets/chapter-9-part-2-images/problem-1/problem-1-part-1.png)

Но във втората има нещо с което трябва да се съобразим. Условието казва следното:

> Всеки следващ ред ще има определена команда. Когато получите командата **"mall.Enter"** на всеки следващ ред ще получите стрингове съдържащи информация относно покупките/действията, които Лина иска да направи.

И тук идва момента, в който трябва да се съобразим - от втория ред нататък трябва да започнем да четем команди, НО чак когато получим командата **"mall.Enter"** трябва да започнем да ги обработваме. Как можем да нарпавим това? `while` или `do-while` цикъл би ни свършил перфектна работа тук. Ето примерно решение на как можем да пропуснем всички команди преди получаването на **"mall.Enter"**:

![](assets/chapter-9-part-2-images/problem-1/problem-1-part-2.png)

Тук е хубаво да отбележим, че извикването на `Console.ReadLine()` след края на цикъла се използва за преминаване към първата команда за обработване.

#### Алгоритъм за решаване

Алгоритъма за решаването на самата задача е праволинеен:
- продължаваме да четем команди от конзолата докато не стигнем до **"mall.Exit"**
- обработваме всеки един знак(`char`) от всяка една команда, спрямо правилата указани в условието.
- модифицираме парите, които Лина има и съхраняваме броя на покупки.

Нека разгледаме първите два проблема пред нашия алгоритъм.

1. Как можем да четем команди докато не срещнем **"mall.Exit"**? Лесно - `while` отговаря точно на това условие.
2. Как можем да достъпим всеки един знак от нашата команда? Т.к. командите ни представляват `string`-ове, най-лесния да достъпим всеки знак в тях е чрез `foreach` цикъл. 

Ето как би изгелждало изглеждало използване на 2 подобни цикъла:

![](assets/chapter-9-part-2-images/problem-1/problem-1-part-3.png)

Следващата част от на алгоритъма ни е да обработим символите от командите ни, спрямо следните правила от условието:

> - Ако символа е **главна буква**, Лина получава 50% намаление, което означава че трябва да намалите парите, които тя има, с 50% от цифровата репрезентация ASCII символа.
> - Ако символа е **малка буква**, Лина получава 70% намаление, което означава че трябва да намалите парите, които тя има, с 30% от цифровата репрезентация ASCII символа.
> - Ако символа е **"%"**, Лина правия покупка която намалява парите и на половина.
> - Ако символа е **"*"**, Лина изтегля пари от дебитната си карта и добавя към наличните си средства 10 лева.
> - Ако символа е **различен от упоменатите горе**, Лина просто прави покупка без намаления и в такъв случай просто извадете стойността на ASCII символа от наличните и средства.

Нека разгледаме проблемите, които стоят пред нас с първото условие.
1. Как можем да разберем дали даден символ представлява главна буква? Можем да използваме един от двата начина:
    - Т.к. буквите в азбуката имат ред, можем да използваме следната проверка `action >= 'A' && action <= 'Z'`
за да проверим дали нашия символ се намира в интервала от големи букви.
    - можем да използваме `char.IsUpper()`.
2. Как можем да прпуснем даден символ, ако той представлява операция, която изисква повече пари, от колкото има Лина? С просто използване на `continue` конструкцията.

Примерната проверка за първата част от условието:

![](assets/chapter-9-part-2-images/problem-1/problem-1-part-4.png)

Забележка: `purchases` е `int` променлива, която държи броя на всички покупки.

Т.к. всички други проверки са доста близки с първата, мислим че читателя не би трябвало да изпита проблем при тяхната имплементация.

#### Форматиране на изхода

В края на задачата трябва да принтираме определен изход, в зависимост от следното условие:

> - Ако не са били направени никакви покупки – "**No purchases. Money left: {останали пари} lv.**"
> - Ако е направена поне една покупка - "**{брой покупки} purchases. Money left: {останали пари} lv.**"

Операциите по принтиране са тривиални, като единственото нещо, с което трябва да се съобразим е:

> Парите трябва да се принтират с точност 2 символа след десетичната запетая.

Как можем да направим това? Ще оставим отговора на този въпрос на читателя.

## Задача 2 - X Expression
Оригинално състезание: [http://bgcoder.com/Contests/Practice/Index/106#2](http://bgcoder.com/Contests/Practice/Index/106#2)

Бони е много мощна вещица. Тъй като силата на природата не е достатъчна за да се бори успешно с вампири и върколаци, те започнала усвоява силата на Изразите.
Израза е много труден за усвояване т.е. заклинанието разчита на способността за **бързо решаване на математически изрази**. За използване на Израз заклинание, вещицата трябва да знае резултата от математическия израз предварително.
Израз заклинанието се състои от няколко прости математически израза. Всеки математически израз може да съдържа оператори за **СЪБИРАНЕ**, **ИЗВАЖДАНЕ**, **ДЕЛЕНИЕ** и/или **УМНОЖЕНИЕ**. Израза се решава както **би бил решен от калкулатор** (вижте последващия пример) и **може да съдържа скоби**. **Всичко в скобите се пресмята първо**. Всеки израз може да съдържа множество скоби, но не може да съдържа вложени скоби:
- Израз съдържащ **(…(…)…) е невалиден**.
- Израз съдържащ **(…)…(…) е валиден**.

### Пример:

Изразът:

![израз](assets/chapter-9-part-2-images/problem-2/matematical-expression.png "Математически израз")


Бива решен по следния начин:

![израз](assets/chapter-9-part-2-images/problem-2/matematical-expression-solution.png "Математически израз")

Т.к. Бони е доста красива, но не чак толкова съобразителна, тя има нужда от нашата помощ за да усвои силата на Изразите.

### Входни данни
Входните данни се състоят от един ред, който бива подаван от конзолата.

Тази единична линя представлява **математически израз за пресмятане**. Линията **винаги завършва с символа „=“**. Символа „=“ означава **край на математическия израз**.

Входните данни винаги са валидни и във формата, който е описана. Няма нужда да бъдат валидирани.

### Изходни данни

Изходните данни трябва да се принтират на конзолата. 

Изхода се състои от един ред – резултата от пресметнатия математически израз.

**Резултата трябва да бъде закръглен до втората цифра след десетичната запетая.**

### Ограничения

- Изразите ще състоят от максимум 2500 символа.
- Числата във всеки математически израз ще са между **[1..9]**
- Операторите в математическите изрази винаги ще бъдат измежду +(събиране), -(изваждане), /(деление) или *(умножение)
- **Резултата от математическия израз ще е в интервала [-100000.00, 100000.00]**
- Позволено време за изпълнение: **0.1 секунди**.
- Позволена памет – **4 MB**.

### Примерен вход и изход

| Вход                           | Изход  |
|--------------------------------|--------|
| 4+6/5+(4\*9–8)/7\*2=             | 8.57   |

| Вход                           | Изход  |
|--------------------------------|--------|
| 3+(6/5)+(2\*3/7)\*7/2\*(9/4+4\*1)= | 110.63 |

### Насоки и подсказки

#### Обработване на входа

Входните ни данни се състоят от точно един ред от конзолата. Тук имаме два начина, по-който можем да обработим входа:
1. Чрез прочитането на целия ред, чрез командата `Console.ReadLine()` и достъпването на всеки един символ(`char`) от реда, чрез `foreach` цикъл.
2. Прочитане входа символ по символ, чрез командата `Console.Read()` и обработване на всеки символ.

За целта на това обяснение ще използваме вариант 2.

![](assets/chapter-9-part-2-images/problem-2/problem-2-part-1.png)

#### Алгоритъм за решаване

За целите на нашата задача, ще имаме нужда от две променливи - една, която да пази текущия резултат и една, която да пази текущия оператор в на нашия израз.

![](assets/chapter-9-part-2-images/problem-2/problem-2-part-2.png)

Забележки:
1. Защо използваме `decimal` тип за да съхраняваме резултата от нашето уравнение? За да избегнем всякакви проблем с точността, които съпътстват `float` и `double` типовете.
2. Защо оператора по подразбиране е `+`? За да може още първото срещнато число да бъде събрано с резултата ни.

След като вече имаме началните си промени, е хубаво да се замислим за основната структура на нашата програма. От условието разбираме, че всеки израз завършва с `=` т.е. ще трябва да четем и обработваме символи докато не срещнем `=`. Това е точното писане на `while` цикъл.

![](assets/chapter-9-part-2-images/problem-2/problem-2-part-3.png)

Следващата стъпка е обработването на нашата `symbol` променлива. Имаме 3 случая за нея:
1. Ако символът е начало на под израз заграден в скоби т.е. срещнатия символ е `(`.
2. Ако символът е цифра между 0 и 9. Но как можем да проверим това? Как можем да проверим дали символа ни е цифра? На помощ тук ни идва ASCII кода на символа, чрез който можем да използваме следната формула: [ASCII кодът на нашия символ] - [ASCII кодът на символа `0`] = цифрата, която репрезентира символа. Ако резултата от тази проверка е между 0 и 9, тогава наши символ, наистина е число.
3. Ако символът е оператор т.е. е `+`, `-`, `*` или `/`.

![](assets/chapter-9-part-2-images/problem-2/problem-2-part-4.png)

Нека разгледаме действията, който трябва да извършим при различните случаи, които дефинирахме:
1. Ако нашият символ е оператор, то тогава единственото, което трябва да направим е да зададем нова стойност на променливата си `expressioOperator`.
2. Ако нашият символ е цифра, тогава трябва да променим текущия резултат от израза в зависимост от текущия оператор т.к. ако `expressioOperator` е `-` тогава трябва да намалим резултата с цифровата репрезентация на текущия символ. Можем да вземем цифровата репрезентация на текущия символ, чрез формулата, която използвахме при проверката на този случай([ASCII кодът на нашия символ] - [ASCII кодът на символа `0`] = цифрата, която репрезентира символа).

![](assets/chapter-9-part-2-images/problem-2/problem-2-part-5.png)

3. Ако нашият символ е `(` или това означава началото на под израз (израз в скоби). По дефиниция  под-израза трябва да се калкулира преди да се модифицира резултата от целия израз (действията в скобите се извършват първи). Това означава че ще имаме локален резултат за под-израза ни и локален оператор.

![](assets/chapter-9-part-2-images/problem-2/problem-2-part-6.png)

След това за пресмятане стойността на под-израза, използваме същите методи, като за пресмятане на главния израз - използваме `while` цикъл за да четим символи(докато не срещнем символа `)`) и във зависимост от това дали прочетения символ е цифра или оператор модифицираме резултата на под-израза. Т.к. имплементацията на тези операции е еднаква с имплементацията за пресмятане на изрази, описана по-горе, читателя не би трябвало да има проблем с нея.

След като приключим калкулацията на резултата от под-израза ни, модифицираме резултата на целия израз в зависимост от стойността на `expressioOperator`.

![](assets/chapter-9-part-2-images/problem-2/problem-2-part-7.png)

#### Форматиране на изхода

Единствения изход, който програмата трябва да принтира на конзолата е резултата от решаването на израза, с точност два символа след десетичната запетая. Как можем да форматираме изхода по този начин? Отговора на този въпрос оставяме на читателя.

## Задача 3 - Bulls and Cows

Оригинално състезание: [https://judge.softuni.bg/Contests/Practice/Index/1#3](https://judge.softuni.bg/Contests/Practice/Index/1#3)

Всички обичаме играта „Бикове и Крави“ (http://en.wikipedia.org/wiki/Bulls_and_cows). При дадено 4 цифрено **тайно число** и 4 цифрено **предполагаемо число**, използваме следните правила:
- Aко имаме цифра от предполагаемото число, която съвпада с цифра от тайното число и е на **същата позиция**, имаме – бик.
- Ако имаме цифра от предполагаемото число, която съвпада с цифра от тайното число, но е **на различна позиция**, имаме – крава.

![пример1](assets/chapter-9-part-2-images/problem-3/bulls-and-cows-example-1.png "Пример")

![пример2](assets/chapter-9-part-2-images/problem-3/bulls-and-cows-example-2.png "Пример")

При дадено тайно число и брой на бикове и крави, нашата задача е **да намерим всички възможни предполагаеми числа** в нарастващ ред.
Aко **не съществуват предполагаеми числа**, които да отговарят на зададените критерии на конзолата трябва да се изпише “No”.

### Входни данни
- Входните данни трябва да се четат от конзолата.
- Входа се състои от 3 реда. Първия ред съдържа секретното число, втория - броя бикове и третия - броя крави.
- Входните данни ще бъдат винаги валидни. Няма нужда да бъдат проверявани.

### Изходни данни
- Изходните данни трябва да се принтират на конзолата.
- Изхода трябва да се състои от един единствен ред – всички предполагаеми числа разделени с единични празно място.
- Aко не съществуват предполагаеми числа, които да отговарят на зададените критерии на конзолата трябва да се изпише “No”.

### Ограничения
- Тайното число винаги ще се състои от 4 цифри в интервала [1..9].
- Броя на кравите и биковете винаги ще е в интервала [0..9].
- Позволено време за изпълнение: **0.15 секунди**.
- Позволена памет: **4 MB**.

### Примерен вход и изход

| Вход           | Изход        |
|----------------|--------------|
| 2228<br>2<br>1 | 1222 2122 2212 2232 2242 2252 2262 2272 2281 2283,2284 2285 2286 2287 2289 2292 2322 2422 2522 2622,2722 2821 2823 2824 2825 2826 2827 2829 2922 3222 4222 5222 6222 7222 8221 8223 8224 8225 8226 8227 8229 9222 |

| Вход           | Изход        |
|----------------|--------------|
| 1234<br>3<br>0 | 1134 1214 1224 1231 1232 1233 1235 1236 1237 1238 1239 1244 1254 1264 1274 1284 1294 1334 1434 1534 1634 1734 1834 1934 2234 3234 4234 5234 6234 7234 8234 9234 |

| Вход           | Изход        |
|----------------|--------------|
| 1234<br>3<br>1 | No           |

### Насоки и подсказки

#### Обработване на входа

За входа на нашата задача имаме 3 реда:
- секретното число.
- броя на бикове.
- броя крави.

Прочитането на този вход е тривиално:

![](assets/chapter-9-part-2-images/problem-3/problem-3-part-1.png)


#### Алгоритъм за решаване

- Flag

![](assets/chapter-9-part-2-images/problem-3/problem-3-part-2.png)



#### Форматиране на изхода

