# Глава 9. Задачи за шампиони (част I)

В настоящата глав ще предложим на читателя няколко малко по-трудни задачи, които имат за цел да развият алгоритмични умения и програмни техники за решаване на задачи с по-висока сложност. Задачите са върхи изучавания в книгата учебен материал, но по трудност надвишават обучайните задачи от приемните изпити в СофтУни. Ако искате да сте шампиони по основи на програмирането, ви препоръчваме да се научите да решавате такива по-сложни задачи, за да ви е лесно по изпитите.

## Crossing sequences (Пресичащи се редици)

Линк към задачата в Judge системата: https://judge.softuni.bg/Contests/Practice/Index/5#3

Имаме две редици: __редица на Трибоначи__, където всяко число е сумата от предните три и __числовата спирала__, дефинирана чрез обхождане на матрица от числа като спирала(дясно, долу, ляво, горе, дясно, долу, горе, ляво, ...) и записване на текущите числа, всеки път когато направим завой. Намерете първото число което се появява и в двете последователности.

### Пример

<img src="assets/chapter-9-images/1_spiral.png" alt="Пример числова спирала" title="Числова спирала" style="float: right; height: 250px;" />

Нека редицата на Трибоначи да започне с 1, 2 и 3. Това означава че ще съдържа числата 1, 2, 3, 6, 11, 20, 37, 68, 125, 230, 423, 778, 1431, 2632, 4841, 8904, 16377, 30122, 55403, 101902, и т.н.

Също така, нека числата в спиралата да започнат с 5 и да се увеличава 2 на всяка стъпка, тогава ще съдържа числата 5, 7, 9, 13, 17, 23, 29, 37, т.н. Тъй като 37 е първото число, което се среща в редицата на Трибоначи и в спиралта, това е отговорът.
<!-- ![Пример числова спирала](assets/chapter-9-images/1_spiral.png "Числова спирала") -->

### Входни данни

Входните данни трябва да бъдат прочетени от кознолата.
* На първите три реда от входа, ще прочетете __три цели числа__, представляващи първите три числа в редицата на Трибоначи.
* На следващите два реда от входа, ще прочетете __две цели числа__, представляващи първото число и стъпката за всяка клетка на матрицата за спиралата от числа.

Входящите данни винаги ще бъдат валидни и винаги ще са в описания формат.  Няма нужда да ги проверявате.

### Изходни данни

Резултатът трябва да бъде принтиран на козолата.

На единствения ред от изхода трябва да принтирате __най-малкото число, което се среща и в двете последователности__. Ако няма число в __диапазона [1...1 000 000]__, което да се среща и в двете последователности, принтирайте "__No__".

### Ограничения

* Всички числа във входа ще бъдат в диапазона [1...1 000 000].
* Позволено работно време за програмта: 0.25 секунди.
* Позволена памет: 16 MB.

### Примерен вход и изход

| Вход | Изход  || Вход | Изход      |
|------|--------||------|------------|
| 1    | 37     || 13   | 13         |
| 2    | &nbsp; || 25   | &nbsp;     |
| 3    | &nbsp; || 99   | &nbsp;     |
| 5    | &nbsp; || 5    | &nbsp;     |
| 2    | &nbsp; || 2    | &nbsp;     |


| Вход | Изход  || Вход | Изход      |
|------|--------||------|------------|
| 1    | 1      || 4    | 71         |
| 1    | &nbsp; || 1    | &nbsp;     |
| 1    | &nbsp; || 7    | &nbsp;     |
| 1    | &nbsp; || 23   | &nbsp;     |
| 1    | &nbsp; || 3    | &nbsp;     |

| Вход | Изход  |
|------|--------|
| 99   | No     |
| 99   | &nbsp; |
| 99   | &nbsp; |
| 2    | &nbsp; |
| 2    | &nbsp; |

### Насоки и подсказки

Първа стъпка от решаването на задачата е да прочетем и обработим на входа. Входните данни се състоят от 5 цели числа - 3 за редицата на Трибоначи и 2 за числовата спирала.

![Пример четене от конзолата](assets/chapter-9-images/1_input.png "Четене от конзолата")

След като имаме входните данни е хубаво да видим как ще генерираме числа в двете редици.

За редицата на Трибоначи, това което трябва да правим всеки път е да събираме предните три стойности и след това да отместим стойностите на трите предишни числа с една позиция напред в редицата т.е. стойността на първото трябва да приеме стойността на второто и т.н.

![Пример генериране число за редицата на  Трибоначи](assets/chapter-9-images/1_tribonacci.png "Генериране на число за редицата на Трибоначи")

Трябва да измилим зависимост между числата в числовата спирала, за да можем да лесно да генерираме всяко следващо число без да се налага да разглеждаме матрици и тяхното обхождане. Ако разгледаме внимателно картинката от условието можем да забележим, че на всеки 2 "завоя" в спиралата числата, които прескачаме се увеличават с 1 т.е. от 5 до 7 и от 7 до 9 не се прескача нито 1 число, ами директно събираме със стъпката на редицата. От 9 до 13 и от 13 до 17 прескачаме едно число т.е. събираме два пъти стъпката. От 17 до 23 и от 23 до 29 прескачаме две числа т.е. събираме три пъти стъпката и т.н.

Така виждаме, че при първите две имаме последното числото + 1\*стъпката, следващите две имат 2\*стъпката и т.н.
Всеки път когато искаме следващото число от сиралата ще трябва да извършваме такава сметка.

![Пример генериране число за числовата спирала](assets/chapter-9-images/1_gen_spiral.png "Генериране на число за числовата спирала")

Това, което трябва да се погрижим е на всеки две числа нашият умножител(може да го наречем коефициент) да се увеличава с 1, което може да се постигне с просто условие от рода на:

![Пример условие за увеличване на коефициента на спиралата](assets/chapter-9-images/1_spiral_step_inc.png "Условие за увеличаване на коефициента")

След като знаем как да генерираме числа и в двете редици можем да пристъпим към обединението им и реално изграждането на крайното решене. Как ще изглежда нашето то - на всяка стъпка ще проверяваме дали числата от двете редици съвпадат, ако това е така ще принтираме на конзолата числото и ще прекратим изпълнението на нашата фунцкия. В противен случай ще видим текущото число, на коя редица е по-малко и ще генерираме следващото, там където "изоставаме". Идеята е, че ще се надяваме при генериране на следващо число да постигнем равенство, а ако нямаме отново ще изпълним горните стъпки.

Знаем, че по условие имаме ограничението, че числата от редиците ще бъдат в диапазона от 1 до 1 000 000. Следователни и ние ще генерираме числа само в този диапазон. Структурата на нашето решение ще изглежда така

![Структура на решението](assets/chapter-9-images/1_solution_structure.png "Структура на решението")

Преди показания `while` цикъл ще трябва да инициализирате променливите `spiralIncrement`, `spiralStepMul`, `spiralCurrent` и `tribonacciCurrent`. Много внимавайте с подбора на начална стойност за `tribonacciCurrent`, защото това може да доведе до пропускане на стойности и липса на точки в judge. След като цялото решение е готово опитайте с различни начални стойности и се опитайте да си обясните от къде идват разликите в точките.

Решението към момента би трябвало да ни дава точки, но със сигурност не и 100. Какво проускаме? Пропускаме факта, че още в началото началното число на спиралата може да бъде равно на някое от трите начални числа от редицата на Трибоначи.

![Подобрено условие за пресичащи се редици](assets/chapter-9-images/1_improved_if.png "Подобрено условие за пресичащи се редици")

Последното нещо, което все още не сме обработили е случаят, в който няма нито едно намерено число, което да съвпада. След изпълнението на нашия `while` цикъл трябва да добавим `Console.WriteLine("No");`. Моля обърнете внимание, че когато принтираме, защото сме намерили съвадащ числа е важно да прекратим изпълнението на цялата програма, а не само на нашия цикъл, защото може да получим извеждане на `No` всеки път, а не само когато няма принтирано число.

## Magic Dates (Магически дати)

Линк към задачата в Judge системата: https://judge.softuni.bg/Contests/Practice/Index/6#3

Да приемем, че ни е зададена __дата__ във формат дд-мм-гггг, например 17-03-2007. Изчисляваме __теглото на тази дата__ като вземем всичките ѝ цифри, умножим всяка цифра с останалите и накрая съберем всички получени резултати. В нашия случай имаме 8 цифри: 17032007, така че теглото е  1\*7 + 1\*0 + 1\*3 + 1\*2 + 1\*0 + 1\*0 + 1\*7 + 7\*0 + 7\*3 + 7\*2 + 7\*0 + 7\*0 + 7\*7 + 0\*3 + 0\*2 + 0\*0 + 0\*0 + 0\*7 + 3\*2 + 3\*0 + 3\*0 + 3\*7 + 2\*0 + 2\*0 + 2\*7 + 0\*0 + 0\*7 + 0\*7 = 144.

Вашата задача е да напишете програма, която намира всички __магически дати: дати между две определени години отговарящи на дадено магическо тегло__. Датите трябва да бъдат принтирани в нарастващ ред във формат дд-мм-гггг. Ще използваме традиционен календар (годините имат 12 месеца, всеки месец има 28, 29, 30 или 31 дни, т.н.)

### Входни данни

Входните данни трябва да бъдат прочетени от конзолата. Състоят се от 3 реда:

*	Първият ред съдържа цяло число - __начална година__
*	Вторият ред съдържа цяло число - __крайна година__
*	Третият ред съдържа цяло число - __магическо тегло__

Входящите данни винаги ще бъдат валидни и винаги ще са в описания формат. Няма нужда да ги проверявате.


### Изходни данни

Резултатът трябва да бъде принтиран на козолата, като последователни дати във __формат дд-мм-гггг__ подредени по азбучен ред. Всеки низ трябва да е на отделен ред. В случай че няма съществуващи магически дати, принтира "__No__".

### Ограничения

* Началната и крайната година са цели числа в периода [1900-2100].
* Магическото тегло е цяло число в диапазона [1...1000].
* Позволено работно време за програмта: 0.25 секунди.
* Позволена памет: 16 MB.


### Примерен вход и изход

| Вход | Изход      || Вход | Изход      |
|------|------------||------|------------|
| 2007 | 17-03-2007 || 2003 | No         |
| 2007 | 13-07-2007 || 2004 |            |
| 144  | 31-07-2007 || 1500 | &nbsp;     |


| Вход | Изход      |
|------|------------|
| 2012 | 09-01-2013 |
| 2014 | 17-01-2013 |
| 80   | 23-03-2013 |
|      | 11-07-2013 |
|      | 01-09-2013 |
|      | 10-09-2013 |
|      | 09-10-2013 |
|      | 17-10-2013 |
|      | 07-11-2013 |
|      | 24-11-2013 |
|      | 14-12-2013 |
|      | 23-11-2014 |
|      | 13-12-2014 |
|      | 31-12-2014 |

| Вход | Изход      |
|------|------------|
| 2011 | 01-01-2011 |
| 2012 | 10-01-2011 |
| 14   | 01-10-2011 |
|      | 10-10-2011 |

TODO: картинка

### Насоки и подсказки

### Тестване в Judge системата


## Five Special Letters (Пет специални букви)

Линк към задачата в Judge системата: https://judge.softuni.bg/Contests/Practice/Index/7#3

Дадени са две числа: __начало__ и __край__. Напишете програма, която __генерира всички комбинации от 5 букви__, всяка от групата {'a', 'b', 'c', 'd', 'e'}, така че теглото на тези 5 букви да е число в интервала [начало...край], включително. Принтирайте ги по азбучен ред, на един ред, разделени с пространство.

__Теглото на една буква__ е изчислено по следния начин: weight('__а__') = __5__; weight('__b__') = __-12__; weight('__c__') = __47__; weight('__d__') = __7__; weight('__e__') = __-32__. __Теглото на редицата__ от букви c1c2…cn е изчислено като се премахват всички букви, които се повтарят (от дясно наляво) и след това се сметне формулата:

<center>weight(c1c2…cn) = 1\*weight(c1) + 2\*weight(c2) + … + n\*weight(cn)</center><br/>
Например, теглото на "bcddc" се изчислява по следния начин:  Първо премахваме повтарящите се букви и получаваме "bcd". След това прилагаме формулата: 1\*weight('b') + 2\*weight('c') + 3\*weight('d') = 1\*(-12) + 2\*47 + 3\*7 = 103. Друг пример: weight("cadea") = weight("cade") = 1\*47 + 2\*5 + 3\*7 - 4\*32 = -50.

### Входни данни

Входните данни трябва да бъдат прочетени от кознолата. Състоят се от два реда:
* Числото за __начало__ е на първия ред.
* Числото за __край__ е на втория ред.

Входните данни винаги ще бъдат валидни и винаги ще са в описания формат. Няма нужда да ги проверявате.


### Изходни данни

Резултатът трябва да бъде принтиран на козолата като поредица от низове, __подредени по азбучен ред__. Всеки низ трябва да бъде отделен от следващия с едно разстояние. Ако теглото на нито един от 5 буквените низове не съществува в зададения интервал, принтирайте "__No__"

### Ограничения

* Числата за __начало__ и __край__ да бъдат цели числа в диапазона [-10000...10000].
* Позволено работно време за програмта: 0.25 секунди.
* Позволена памет: 16 MB.

### Примерен вход и изход

| Вход | Изход       | Коментар             |
|------|-------------|----------------------|
| 40   | bcead bdcea | weight("bcead") = 41 |
| 42   | &nbsp;      | weight("bdcea") = 40 |

| Вход | Изход         |
|------|---------------|
| -1   | bcdea cebda eaaad eaada eaadd eaade eaaed eadaa eadad eadae eadda eaddd eadde eadea eaded eadee eaead eaeda eaedd eaede eaeed eeaad eeada eeadd eeade eeaed eeea |
| 1    | &nbsp;        |

| Вход | Изход      |
|------|------------|
| 200  | baadc babdc badac badbc badca badcb badcc badcd baddc bbadc bbdac bdaac bdabc bdaca bdacb bdacc bdacd bdadc bdbac bddac beadc bedac eabdc ebadc ebdac edbac   |
| 300  | &nbsp;     |

| Вход | Изход  |
|------|--------|
| 300  | No     |
| 400  | &nbsp; |

TODO: картинка

### Насоки и подсказки

### Тестване в Judge системата
