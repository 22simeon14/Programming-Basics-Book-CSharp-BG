# Глава 4. По-сложни проверки

В **настоящата** глава ще разгледаме **вложените проверки** в езика **`C#`**, чрез които нашата програма може да съдържа **условни конструкции**, в които има **вложени други условни конструкции**. Наричаме ги **"вложени"**, защото **поставяме `if`** конструкция в **друга `if`** конструкция. Ще разгледаме **по-сложни логически условия** с подходящи примери.

<div class="video-player">
  Гледайте видео-урок по тази глава тук: <a target="_blank"
  href="https://www.youtube.com/watch?v=z8XxYIyesz0">
  https://www.youtube.com/watch?v=z8XxYIyesz0</a>.
</div>
<script src="/assets/js/video.js"></script>


## Вложени проверки

Конструкциите **`if-else`** могат да се **влагат една в друга**:

![code](/assets/chapter-4-images/00.If-else-construction.png)

### Задача: Обръщение според възраст и пол

Според въведени **възраст** (десетично число) и **пол** (**m** / **f**) да се отпечата обръщение:
* “**Mr.**” – мъж (пол “**m**”) на 16 или повече години
* “**Master**” – момче (пол “**m**”) под 16 години
* “**Ms.**” – жена (пол “**f**”) на 16 или повече години
* “**Miss**” – момиче (пол “**f**”) под 16 години

Можем да забележим, че **изходът** на програмата **зависи от няколко неща**. **Първо** трябва да проверим какъв **пол** е въведен и **после** да проверим **възрастта**. Съответно ще използваме **повече от един** `if-else` блока. Тези блокове ще бъдат **вложени**, т.е. от **резултата** на първия ще **определим** кои от **другите** да изпълним.

![task1](/assets/chapter-4-images/01.Personal Titles-01.png)

|Вход|Изход|Вход|Изход|
|----|----|----|----|
|12<br>f|Miss|17<br>m|Mr.|

|Вход|Изход|Вход|Изход|
|----|----|----|----|
|25<br>f|Ms.|13.5<br>m|Master|

#### Решение:

![code](/assets/chapter-4-images/01.Personal Titles-02.png)

#### Тестване на решението: 
Тествайте решението си тук: https://judge.softuni.bg/Contests/Practice/Index/508#0


### Задача: Квартално магазинче

Предприемчив българин отваря по едно **квартално магазинче** в **няколко града** с различни **цени** за следните **продукти**:

|продукт / град|Sofia|Plovdiv|Varna|
|:-------:|:-------:|:-------:|:-------:|
|coffee<br>water<br>beer<br>sweets<br>peanuts|0.50<br>0.80<br>1.20<br>1.45<br>1.60<br>|0.40<br>0.70<br>1.15<br>1.30<br>1.50<br>|0.45<br>0.70<br>1.10<br>1.35<br>1.55|

По даден **град** (стринг), **продукт** (стринг) и **количество** (десетично число) да се пресметне цената.

|Вход|Изход|Вход|Изход|
|-------|-------|-------|-------|
|coffee<br>Varna<br>2|0.9|peanuts<br>Plovidv<br>1|1.5|

|Вход|Изход|Вход|Изход|
|-------|-------|-------|-------|
|beer<br>Sofia<br>6|7.2|water<br>Plovdiv<br>3|2.1|

#### Решение:

**Прехвърляме** всички букви в **долен регистър** с **`.ToLower()`**, за да сравняваме продукти и градове **без значение** на малки/ главни букви.

![code](/assets/chapter-4-images/02.Small-shop-01.png)

#### Тестване на решението: 
Тествайте решението си тук: https://judge.softuni.bg/Contests/Practice/Index/508#1



## По-сложни проверки

Нека разгледаме как можем да правим по-сложни логически проверки. Може да използваме логическо "**и**", логическо "**или**", логическо **отрицание** и **скоби**


## Логическо "И"

Както видяхме, в някои задачи се налага да правим **много проверки наведнъж**. Но какво става, когато, за да изпълним някакъв код, трябва да бъдат изпълнени **повече** условия и **не искаме** да правим **отрицание** (`else`) за всяко едно от тях? Вариантът с вложените `if-блокове` е валиден, но кодът би изглеждал много **неподреден** и със сигурност - **труден** за поддръжка.  

Логическо "**И**" (оператор **`&&`**) означава няколко условия да са **изпълнени едновременно**:

![code](/assets/chapter-4-images/00.Logical-and-01.png)

|a|b|a && b|
|:-----:|:-----:|:-----:|
|True<br>True<br>False<br>False|True<br>False<br>True<br>False|True<br>False<br>False<br>False|


### Как работи операторът `&&`?

Операторът **`&&`** приема **няколко** булеви (условни) израза, които имат стойност **`true`** или **`false`**, и ни връща **един** булев израз като **резултат**. Използването му **вместо** редица вложени **`if`** блокове прави кода **по-четлив**, **подреден** и **лесен** за поддръжка. Но как **работи**, когато поставим **няколко** условия едно след друго? Както видяхме по-горе, логическото **"И"** връща **`true`**, **само** когато приема като **аргументи изрази** със стойност **`true`**. Съответно, когато имаме **последователност** от аргументи, логическото "И" **проверява** или докато **свършат** аргументите, или докато не **срещне** аргумент със стойност **`false`**. 

Пример:

![code](/assets/chapter-4-images/00.Logical-and-02.png)

**Програмата** ще се изпълни по **следния** начин: **започва** проверката от **`а`**, **прочита** я и отчита, че има стойност **`true`**, след което **проверява** **`b`**. След като е **отчелa**, че **`a`** и **`b`** връщат стойност **`true`**, **проверява следващия** аргумент. Стига до **`c`** и отчита, че **променливата** има стойност **`false`**. След като програмата отчете, че аргументът **`c`** има стойност **`false`**, тя изчислява израза **до `c`**, **независимо** каква е стойността на **`d`**. За това проверката на **`d`** се **прескача** и **целият** израз бива изчислен като **`false`**.

### Задача: Точка в правоъгълник

Проверка дали **точка {x, y}** се намира **вътре в правоъгълника {x1, y1} – {x2, y2}**. Входните данни се четат от конзолата и се състоят от 6 реда: десетичните числа **x1**, **y1**, **x2**, **y2**, **x** и **y** (като се гарантира, че **x1 < x2** и **y1 < y2**).

|Вход |Изход |
|-----|------|
|2<br>-3<br>12<br>3<br>8<br>-1|Inside|


Графика за примерния вход и изход:

![shop](/assets/chapter-4-images/03.Point-in-rectangle-01.png)

Една точка е вътрешна за даден многоъгълник, ако **едновременно** са изпълнени следните четири условия:
* Точката е надясно от лявата страна на правоъгълника
* Точката е наляво от дясната страна на правоъгълника
* Точката е надолу от горната страна на правоъгълника
* Точката е нагоре от долната страна на правоъгълника

#### Решение:

![code](/assets/chapter-4-images/03.Point-in-rectangle-02-fix.PNG)

#### Тестване на решението: 
Тествайте решението си тук: https://judge.softuni.bg/Contests/Practice/Index/508#2


## Логическо "ИЛИ"

Логическо **"ИЛИ"** (оператор **`||`**) означава да е **изпълнено поне едно** измежду няколко условия. Подобно на оператора **`&&`**, логическото **"ИЛИ"** приема **няколко** аргумента от **булев** (условен) тип и връща **`true`** или **`false`**. Лесно можем да се досетим, че **получаваме** като стойност **`true`**, винаги когато поне **един** от аргументите има стойност **`true`**. Типичен пример за логиката на този оператор е следният:

В училище учителят казва: "Иван или Петър да измият дъската". За да бъде изпълнено това условие (дъската да бъде измита), е възможно само Иван да я измие, само Петър или и двамата да го направят.

|a|b|a &#124;&#124; b|
|:-----:|:-----:|:-----:|
|True<br>True<br>False<br>False|True<br>False<br>True<br>False|True<br>True<br>True<br>False|


### Как работи операторът `||` ?

Вече научихме какво **представлява** логическото **"ИЛИ"**. Но как всъщност се реализира? Както при логическото **"И"**, програмата **проверява** от ляво на дясно **аргументите**, които са зададени. За да получим **`true`** от израза, е необходимо **само един** аргумент да има стойност **`true`**, съответно проверката **продължава** докато се срещне **аргумент** с **такава** стойност или докато **не свършат** аргументите.

![code](/assets/chapter-4-images/00.Logical-or-01.png)

Програмата **проверява `а`**, отчита, че има стойност **`false`** и продължава. Стигайки до **`b`**, отчита, че има стойност **`true`** и целият **израз** получава стойност **`true`**, **без** да се проверява **`c`** и **`d`**, защото техните стойности **не биха променили** резултата на израза.

![code](/assets/chapter-4-images/00.Logical-or-02.png)

### Задача: Плод или зеленчук

Нека проверим дали даден **продукт** е **плод** или **зеленчук**. Плодовете "**fruit**" са **banana**, **apple**, **kiwi**, **cherry**, **lemon** и **grapes**. Зеленчуците "**vegetable**" са **tomato**, **cucumber**, **pepper** и **carrot**. Всички останали са "**unknown**"

|Вход|Изход|
|----|----|
|banana<br>tomato<br>java|fruit<br>vegetable<br>unknown|

#### Решение:

![code](/assets/chapter-4-images/04.Fruit-or-vegetable-01.png)

#### Тестване на решението: 
Тествайте решението си тук: https://judge.softuni.bg/Contests/Practice/Index/508#3


## Логическо отрицание

**Логическо отрицание** (оператор **`!`**) означава да **не е изпълнено** дадено условиe.

|**a**|**!a**|
|:----:|:----:|
|True|False|

Операторът **`!`** приема като **аргумент** булева променлива и **обръща** стойността ѝ.

### Задача: Невалидно число

Дадено **число е валидно**, ако е в диапазона **[100…200]** или е **0**. Да се направи проверка за **невалидно** число.

#### Решение:

![code](/assets/chapter-4-images/05.Invalid-number-01.png)

#### Тестване на решението: 
Тествайте решението си тук: https://judge.softuni.bg/Contests/Practice/Index/508#4


## По-сложни логически условия

### Задача: Точка върху страна на правоъгълник

Да се напише програма, която проверява дали **точка {x, y}** се намира **върху някоя от страните на правоъгълник {x1, y1} - {x2, y2}**. Входните данни се четат от конзолата и се състоят от 6 реда: десетичните числа **x1**, **y1**, **x2**, **y2**, **x** и **y** (като се гарантира, че **x1 < x2** и **y1 < y2**). Да се отпечата "**Border**" (точката лежи на някоя от страните) или "**Inside / Outside**" (в противен случай).

![rect](/assets/chapter-4-images/06.Point-on-rectangle-border-01.png)

|Вход|Изход|Вход|Изход|
|-----|-----|-----|-----|
|2<br>-3<br>12<br>3<br>12<br>-1|Border|2<br>-3<br>12<br>3<br>8<br>-1|Inside/Outside

Точка лежи върху някоя от страните на правоъгълник, ако:
* x съвпада с x1 или x2 и същевременно y е между y1 и y2 или
* y съвпада с y1 или y2 и същевременно x е между x1 и x2

#### Решение:

![code](/assets/chapter-4-images/06.Point-on-rectangle-border-02.png)

Предходното условие може да се опрости по този начин:

![code](/assets/chapter-4-images/06.Point-on-rectangle-border-03.png)

#### Тестване на решението: 
Тествайте решението си тук: https://judge.softuni.bg/Contests/Practice/Index/508#5

### Задача: Магазин за плодове

Магазин за плодове в **работни дни** продава на следните **цени**:

|плод|цена|
|:-----:|:-----:|
|banana<br>apple<br>orange<br>grapefruit<br>kiwi<br>pineapple<br>grapes|2.50<br>1.20<br>0.85<br>1.45<br>2.70<br>5.50<br>3.85|

В почивни дни цените са **по-високи**:

|плод|цена|
|:-----:|:-----:|
|banana<br>apple<br>orange<br>grapefruit<br>kiwi<br>pineapple<br>grapes|2.70<br>1.25<br>0.90<br>1.60<br>3.00<br>5.60<br>4.20|

Нека напишем програма, която чете от конзолата **плод**, **ден от седмицата** и **количество** (десетично число), след което пресмята **цената** според цените от таблиците по-горе. Резултатът ще отпечатаме **закръглен с 2 цифри** след десетичния знак. При невалиден ден от седмицата или невалидно име на плод ще се отпечата **"error"**.

|Вход|Изход|Вход|Изход|
|----|----|----|----|
|orange<br>Sunday<br>3|2.70|kiwi<br>Monday<br>2.5|6.75|

|Вход|Изход|Вход|Изход|
|----|----|----|----|
|grapes<br>Saturday<br>0.5|2.10|tomato<br>Monday<br>0.5|error|

#### Решение:

![code](/assets/chapter-4-images/07.Fruit-shop-01.png)

#### Тестване на решението: 
Тествайте решението си тук: https://judge.softuni.bg/Contests/Practice/Index/508#6

### Задача: Търговски комисионни

Фирма дава следните **комисионни** на търговците си според **града**, в който работят и **обема на продажбите s**:

|Град|0 <= s <= 500|500 <= s <= 1 000|1 000 <= s <= 10 000|s > 10 000|
|:----:|:----:|:----:|:----:|:----:|
|Sofia<br>Varna<br>Plovdiv|5%<br>4.5%<br>5.5%|7%<br>7.5%<br>8%|8%<br>10%<br>12%|12%<br>13%<br>14.5%|

Нека напишем **програма**, която чете име на **град** (стринг) и обем на **продажбите** (десетично число) и изчислява размера на  комисионната. Резултатът ще изведем закръглен с **2 десетични цифри след десетичната запетая**. При **невалиден град или обем на продажбите** (отрицателно число) ще отпечатваме "**error**".

|Вход|Изход|Вход|Изход|
|:-----:|:-----:|:-----:|:-----:|
|Sofia<br>1500|120.00|Plovidv<br>499.99|27.50|


|Вход|Изход|Вход|Изход|
|:-----:|:-----:|:-----:|:-----:|
|Sofia<br>1500|120.00|Plovidv<br>499.99|27.50|

![code](/assets/chapter-4-images/08.Trade-comissions-01.png)

#### Тестване на решението: 
Тествайте решението си тук: https://judge.softuni.bg/Contests/Practice/Index/508#7

<table><tr><td><img src="/assets/alert-icon.png" style="max-width:50px" /></td>
<td><b>Добра практика</b> е да използваме <b>блокове</b>, които <b>заграждаме</b> с къдрави скоби <b>{ }</b> след <b>if</b> и <b>else</b>. Също така е препоръчително при писане да <b>отместваме</b> кода <b>след if и else</b> с една табулация <b>навътре</b>, за да направим кода по-лесно четим.</td>
</tr></table>

## Условна конструкция `switch-case`

Конструкцията **`switch-case`** работи като поредица **`if-else`** блокове. Когато работата на програмата ни зависи от стойността на **една променлива**, вместо да правим последователни проверки с `if-else` блокове, можем да **използваме** условната конструкция **`switch`**. Тя се използва за **избор измежду списък с възможности**. Конструкцията сравнява дадена стойност с определени константи и в зависимост от резултата предприема действие.

**Променливата**, която искаме да **сравняваме**, поставяме в **скобите след оператора `switch`** и се нарича "**селектор**". Тук типът трябва да е сравним (числа, стрингове, булеви изрази). **Последователно** започва **сравняването** с всяка една **стойност**, която **се намира** след **`case` етикетите**. При съвпадение започва изпълнението на кода от съответното място и продължава, докато стигне оператора **`break`**. В някои програмни езици (като C и C++) `break` може да се изпуска, за да се изпълнява код от друга `case` конструкция, докато не стигне до въпросния оператор. В `C#` обаче, **`break`** е **задължителен** за **всеки `case`**, който съдържа изпълнение на програмна логика. При **липса** на **съвпадение**, се изпълнява **`default`** конструкцията, **ако** такава **съществува**.

![code](/assets/chapter-4-images/00.Switch-case-01.png)

### Задача: Ден от седмицата

Нека напишем програма, която принтира **деня от седмицата** (на английски) според **въведеното число** (1...7).

|Вход|Изход|
|-----|-----|
|1<br>7<br>-1|Monday<br>Sunday<br>error|

#### Решение:

![code](/assets/chapter-4-images/09.Day-of-week-01.png)

<table><tr><td><img src="/assets/alert-icon.png" style="max-width:50px" /></td>
<td><b>Добра практика</b> е на <b>първо</b> място да поставяме онези <b>case случаи</b>, които обработват <b>най-често случилите се ситуации</b>, а <b>case конструкциите</b>, обработващи <b>по-рядко възникващи ситуации</b>, да оставим в <b>края преди default конструкцията</b>. Друга <b>добра практика</b> е да <b>подреждаме case етикетите</b> в <b>нарастващ ред</b>, без значение дали са челочислени или символни.</td>
</tr></table>

#### Тестване на решението: 
Тествайте решението си тук: https://judge.softuni.bg/Contests/Practice/Index/508#8


### Множество етикети в switch-case

В **`C#`** имаме възможността да **използваме множество `case`**, когато те трябва да изпълняват **един и същи** код. При този начин на записване, когато **програмата** ни намери **съвпадение**, ще изпълни **следващия** срещнат код, тъй като **след** съответния **`case`** етикет **липсва код** за изпълнение и **`break`** оператор. Ако такъв **липсва**, ще се **изпълни `default`** конструкцията.

![code](/assets/chapter-4-images/00.Swtich-case-02.png)

### Задача: Вид животно

Напишете програма, която принтира вида на животно според името му: 

* **dog** -> **mammal**
* **crocodile, tortoise, snake** -> **reptile**
* **others** -> **unknown**

![code](/assets/chapter-4-images/10.Animal-type-01.png)

#### Тестване на решението:
Тествайте решението си тук: https://judge.softuni.bg/Contests/Practice/Index/508#9


## Какво научихме от тази глава?

#### Вложени проверки:

![code](/assets/chapter-4-images/00.If-else-construction.png)

#### По-сложни проверки с `&&`, `||`, `!` и `()`:

![code](/assets/chapter-4-images/00.Logical-or-and-not.png)

#### Switch-case провеки

![code](/assets/chapter-4-images/00.Switch-case-01.png)



## Упражнения: по-сложни проверки

### Задача: Кино

В една кинозала столовете са наредени в **правоъгълна** форма в **r** реда и **c** колони. Има три вида прожекции с билети на **различни** цени:
* **Premiere** – премиерна прожекция, на цена **12.00** лева.
* **Normal** – стандартна прожекция, на цена **7.50** лева.
* **Discount** – прожекция за деца, ученици и студенти на намалена цена от **5.00** лева.

Напишете програма, която въвежда **тип прожекция** (стринг), брой **редове** и брой **колони** в залата (цели числа) и изчислява **общите приходи** от билети при **пълна зала**. Резултатът да се отпечата във формат като в примерите по-долу - с 2 знака след десетичната точка.

|Вход|Изход|
|-----|-----|
|Premiere<br>10<br>12|1440.00 leva|Normal<br>21<br>13|2047.50 leva|

#### Тестване на решението: 
Тествайте решението си тук: https://judge.softuni.bg/Contests/Practice/Index/508#10


### Задача: Волейбол

Влади е студент, живее в София и си ходи от време на време до родния град. Той е много запален по волейбола, но е зает през работните дни и играе **волейбол** само през **уикендите** и в **празничните дни**. Влади играе **в София** всяка **събота**, когато **не е на работа** и **не си пътува до родния град**, както и в **2/3 от празничните дни**. Той пътува до **родния си град h пъти** в годината, където играе волейбол със старите си приятели в **неделя**. Влади **не е на работа 3/4 от уикендите**, в които е в София. Отделно, през **високосните години** Влади играе с **15% повече** волейбол от нормалното. Приемаме, че годината има точно **48 уикенда**, подходящи за волейбол. 
Напишете програма, която изчислява **колко пъти Влади е играл волейбол** през годината. **Закръглете резултата** надолу до най-близкото цяло число (например 2.15 -> 2; 9.95 -> 9).

Входните данни се четат от конзолата:
* Първият ред съдържа думата “**leap**” (високосна година) или “**normal**” (нормална година с 365 дни).
* Вторият ред съдържа цялото число **p** – брой празници в годината (които не са събота или неделя).
* Третият ред съдържа цялото число **h** – брой уикенди, в които Влади си пътува до родния град.

|Вход|Изход|Вход|Изход|
|-----|-----|-----|-----|
|leap<br>5<br>2|45|normal<br>3<br>2|38|

|Вход|Изход|Вход|Изход|
|-----|-----|-----|-----|
|normal<br>11<br>6|44|leap<br>0<br>1|41|

#### Тестване на решението:
Тествайте решението си тук: https://judge.softuni.bg/Contests/Practice/Index/508#11

### Задача: * Точка във фигурата

**Фигура** се състои от **6 блокчета с размер h * h**, разположени като на фигурата. Долният ляв ъгъл на сградата е на позиция {0, 0}. Горният десен ъгъл на фигурата е на позиция {**2\*h**, **4\*h**}. На фигурата координатите са дадени при **h = 2**. 
Напишете програма, която въвежда цяло число **h** и координатите на дадена **точка {x, y}** (цели числа) и отпечатва дали точката е вътре във фигурата (**inside**), вън от фигурата (**outside**) или на някоя от стените на фигурата (**border**).

![PointInFigure](/assets/chapter-4-images/13.Point-in-the-figure-01.png)

* Може да разделите фигурата на **два правоъгълника** с обща стена.
* Една точка е **външна (outside)** за фигурата, когато е едновременно **извън** двата правоъгълника.
* Една точка е **вътрешна (inside)** за фигурата, ако е вътре в някой от правоъгълниците (изключвайки стените им) или лежи върху общата им стена.
* В **противен случай** точката лежи на стената на правоъгълника (**border**).

|Вход|Изход|Вход|Изход|
|-----|-----|-----|-----|
|2<br>3<br>10|outside|2<br>3<br>1|inside|


|Вход|Изход|Вход|Изход|
|-----|-----|-----|-----|
|2<br>2<br>2|border|2<br>6<br>0|border|


|Вход|Изход|Вход|Изход|
|-----|-----|-----|-----|
|2<br>0<br>6|outside|15<br>13<br>55|outside|


|Вход|Изход|Вход|Изход|
|-----|-----|-----|-----|
|15<br>29<br>37|inside|15<br>37<br>18|outside|

|Вход|Изход|Вход|Изход|
|-----|-----|-----|-----|
|15<br>-4<br>7|outside|15<br>30<br>0|border|


#### Тестване на решението: 
Тествайте решението си тук: https://judge.softuni.bg/Contests/Practice/Index/508#12

## Упражнения: графични и уеб приложения

### Задача: * Точка и правоъгълник – графично (GUI) приложение
Да се разработи графично (**GUI**) приложение за **визуализация на точка и правоъгълник**. Приложението трябва да изглежда приблизително по следния начин:

![PointAndFigure](/assets/chapter-4-images/14.Point-in-rectangle-gui-01.png)

![PointAndFigure](/assets/chapter-4-images/14.Point-in-rectangle-gui-02.png)

![PointAndFigure](/assets/chapter-4-images/14.Point-in-rectangle-gui-03.png)

От контролите вляво се задават координатите на **два от ъглите на правоъгълник** (десетични числа) и координатите на **точка**. Приложението **визуализира графично** правоъгълника и точката и изписва дали точката е **вътре** в правоъгълника (**Inside**), **вън** от него (**Outside**) или на някоя от стените му (**Border**).
Приложението **премества и мащабира** координатите на правоъгълника и точката, за да бъдат максимално големи, но да се събират в полето за визуализация в дясната страна на приложението.

<table><tr><td><img src="/assets/alert-icon.png" style="max-width:50px" /></td>
<td>Внимание: това приложение е значително <b>по-сложно</b> от предходните графични приложения, които разработвахте до сега, защото изисква ползване на функции за чертане и нетривиални изчисления за преоразмеряване и преместване на правоъгълника и точката. Следват инструкции за изграждане на приложението стъпка по стъпка.</td>
</tr></table>

1. Създайте нов **Windows Forms Application** с подходящо име, например “**Point-and-Rectangle**”:

![PointAndFigure](/assets/chapter-4-images/14.Point-in-rectangle-gui-04.png)

2. **Наредете контролите** във формата, както е показано на фигурата по-долу: 6 кутийки за въвеждане на число (**`NumericUpDown`**) с надписи (**`Label`**) пред всяка от тях, бутон (**`Button`**) за изчертаване на правоъгълника и точката и текстов блок за резултата (**`Label`**). Нагласете **размерите** и **свойствата** на контролите, за да изглеждат приблизително като на картинката:

![PointAndFigure](/assets/chapter-4-images/14.Point-in-rectangle-gui-05.png)

3. Задайте следните препоръчителни настройки на контролите:

   За **главната форма (Form)**, която съдържа всички контроли:
   *	(name) = **FormPointAndRectangle**
   *	**Text** = **"Point and Rectangle"**
   *	**Font.Size** = **12**
   *	**Size** = **700**, **410**
   *	**MinimumSize** = **500**, **400**
   *	**FormBorderStyle** = **FixedSingle**

   За **полетата за въвеждане на число (NumericUpDown)**:
   *	(name) = **numericUpDownX1**; **numericUpDownY1**; **numericUpDownX2**; **numericUpDownY2**; **numericUpDownX**; **numericUpDownY**
   *	**Value** = **2**; **-3**; **12**; **3**; **8**; **-1**
   *	**Minimum** = **-100000**
   *	**Maximum** = **100000**
   *	**DecimalPlaces** = **2**

   За **бутона (Button)** за **визуализация** на правоъгълника и точката:
   *	(name) = **buttonDraw**
   *	**Text** = **“Draw”**

   За **текстовия блок за резултата (Label)**:
   *	(name) = **labelLocation**
   *	**AutoSize** = **False**
   *	**BackColor** = **PaleGreen**
   *	**TextAlign** = **MiddleCenter**

   За **полето с чертежа (PictureBox)**:
   *	(name) = **pictureBox**
   *	**Anchor** = **Top**, **Bottom**, **Left**, **Right**


4. 	Хванете следните **събития**, за да напишете C# кода, който ще се изпълни при настъпването им:

    *	Събитието **Click** на бутона **buttonDraw** (извиква се при натискане на бутона).
    *	Събитието **ValueChanged** на контролите за въвеждане на числа **numericUpDownX1**, **numericUpDownY1**, **numericUpDownX2**, **numericUpDownY2**, **numericUpDownX** и **numericUpDownY** (извиква се при промяна на стойността в контролата за въвеждане на число).
    *	Събитието **Load** на формата **FormPointAndRectangle** (извиква се при стартиране на приложението, преди да се появи главната форма на екрана).
    *	Събитието **Resize** на формата **FormPointAndRectangle** (извиква се при промяна на размера на главната формата).

5. 	Всички изброени по-горе събития ще изпълняват едно и също действие – **`Draw()`**, което ще визуализира правоъгълника и точката и ще показва дали тя е вътре, вън или на някоя от страните. Кодът трябва да изглежда така: 

```csharp
private void buttonDraw_Click(object sender, EventArgs e)
{
    Draw();
}

private void FormPointAndRectangle_Load(object sender, EventArgs e)
{
    Draw();
}

private void FormPointAndRectangle_Resize(object sender, EventArgs e)
{
    Draw();
}

private void numericUpDownX1_ValueChanged(object sender, EventArgs e)
{
    Draw();
}

 /*TODO: implement the same way event handlers numericUpDownY1_ValueChanged, 
            numericUpDownX2_ValueChanged, numericUpDownY2_ValueChanged, 
            numericUpDownX_ValueChanged and 
            numericUpDownY_ValueChanged*/

private void Draw()
{
    // TODO: implement this a bit later …
}

```

6. Започнете от по-лесната част: **печат на информация къде е точката спрямо правоъгълника** (Inside, Outside или Border). Можете да ползвате следния код:

```csharp
private void Draw()
{
    // Get the rectangle and point coordinates from the form
    var x1 = this.numericUpDownX1.Value;
    var y1 = this.numericUpDownY1.Value;
    var x2 = this.numericUpDownX2.Value;
    var y2 = this.numericUpDownY2.Value;
    var x = this.numericUpDownX.Value;
    var y = this.numericUpDownY.Value;

    // Display the location of the point: Inside / Border / Outside
    DisplayPointLocation(x1, y1, x2, y2, x, y);
}

private void DisplayPointLocation(
    decimal x1, decimal y1, decimal x2, decimal y2, decimal x, decimal y)
{
    var left = Math.Min(x1, x2);
    var right = Math.Max(x1, x2);
    var top = Math.Min(y1, y2);
    var bottom = Math.Max(y1, y2);
    if (x > left && x < right && …)
    {
        this.labelLocation.Text = "Inside";
        this.labelLocation.BackColor = Color.LightGreen;
    }
    else if (… || y < top || y > bottom)
    {
        this.labelLocation.Text = "Outside";
        this.labelLocation.BackColor = Color.LightSalmon;
    }
    else
    {
        this.labelLocation.Text = "Border";
        this.labelLocation.BackColor = Color.Gold;
    }
}
```
Помислете как **да допишете** недовършените (нарочно) условия в `if` проверките! Кодът по-горе **нарочно не се компилира**, защото целта  му е да помислите как и защо работи и да **допишете липсващите части**.
Горният код взима координатите на правоъгълника и точките и проверява дали точката е вътре, вън или на страната на правоъгълника. При    визуализацията на резултата се сменя и цвета на фона на текстовия блок, който го съдържа.

7. Остава да се имплементира най-сложната част: визуализация на правоъгълника и точката в контролата **`pictureBox`** с преоразмеряване. Можете да ползвате **кода по-долу**, който прави малко изчисления и рисува син правоъгълник и тъмносиньо кръгче (точката) според зададените във формата координати. За съжаление сложността на кода надхвърля изучавания до момента материал и е сложно да се обясни в детайли как точно работи. Можете да разгледате коментарите за ориентация. Това е пълната версия на действието **`Draw()`**:

```csharp
private void Draw()
{
  // Get the rectangle and point coordinates from the form
  var x1 = this.numericUpDownX1.Value;
  var y1 = this.numericUpDownY1.Value;
  var x2 = this.numericUpDownX2.Value;
  var y2 = this.numericUpDownY2.Value;
  var x = this.numericUpDownX.Value;
  var y = this.numericUpDownY.Value;

  // Display the location of the point: Inside / Border / Outside
  DisplayPointLocation(x1, y1, x2, y2, x, y);

  // Calculate the scale factor (ratio) for the diagram holding the
  // rectangle and point in order to fit them well in the picture box
  var minX = Min(x1, x2, x);
  var maxX = Max(x1, x2, x);
  var minY = Min(y1, y2, y);
  var maxY = Max(y1, y2, y);
  var diagramWidth = maxX - minX;
  var diagramHeight = maxY - minY;
  var ratio = 1.0m;
  var offset = 10;
  if (diagramWidth != 0 && diagramHeight != 0)
  {
    var ratioX = (pictureBox.Width - 2 * offset - 1) / diagramWidth;
    var ratioY = (pictureBox.Height - 2 * offset - 1) / diagramHeight;
    ratio = Math.Min(ratioX, ratioY);
  }

  // Calculate the scaled rectangle coordinates
  var rectLeft = offset + (int)Math.Round((Math.Min(x1, x2) - minX) * ratio);
  var rectTop = offset + (int)Math.Round((Math.Min(y1, y2) - minY) * ratio);
  var rectWidth = (int)Math.Round(Math.Abs(x2 - x1) * ratio);
  var rectHeight = (int)Math.Round(Math.Abs(y2 - y1) * ratio);
  var rect = new Rectangle(rectLeft, rectTop, rectWidth, rectHeight);

  // Calculate the scalled point coordinates
  var pointX = (int)Math.Round(offset + (x - minX) * ratio);
  var pointY = (int)Math.Round(offset + (y - minY) * ratio);
  var pointRect = new Rectangle(pointX - 2, pointY - 2, 5, 5);

  // Draw the rectangle and point
  pictureBox.Image = new Bitmap(pictureBox.Width, pictureBox.Height);
  using (var g = Graphics.FromImage(pictureBox.Image))
  {
    // Draw diagram background (white area)
    g.Clear(Color.White);

    // Draw the rectangle (scalled to the picture box size)
    var pen = new Pen(Color.Blue, 3);
    g.DrawRectangle(pen, rect);

    // Draw the point (scalled to the picture box size)
    pen = new Pen(Color.DarkBlue, 5);
    g.DrawEllipse(pen, pointRect);
  }
}

private decimal Min(decimal val1, decimal val2, decimal val3)
{
  return Math.Min(val1, Math.Min(val2, val3));
}

private decimal Max(decimal val1, decimal val2, decimal val3)
{
  return Math.Max(val1, Math.Max(val2, val3));
}
```

   В горния код се срещат доста **преобразувания на типове**, защото се работи с различни типове числа (десетини числа, реални числа и цели числа) и понякога се изисква да се преминава между тях.

8. **Компилирайте кода**. Ако има грешки, ги отстранете. Най-вероятната **причина** за грешка е **несъответстващо име на някоя от контролите** или ако **сте написали кода на неправилно място**.

9.	**Стартирайте приложението** и го **тествайте**. Пробвайте да въвеждате различни правоъгълници и позиционирайте точката на различни позиции, преоразмерявайте приложението и вижте дали се държи коректно.
