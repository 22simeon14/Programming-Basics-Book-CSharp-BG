# Глава 8. Подготовка за практически изпит (изпитни задачи от 18-December-2016)

В настоящата глава ще разгледаме един практически изпит по основи на програмирането, проведен в СофтУни на 18 декември 2016 г. Задачите дават добра представа какво можем да очакваме на изпита за прием в СофтУни. Изпитът покрива изучавания учебен материал от настоящата книга и от курса "Programming Basics" в СофтУни.


## Задача 1. Разстояние

Напишете програма която да пресмята **колко километра изминава кола**, за която **знаем първоначалната скорост \(км/ч\)**, **времето в минути след което увеличава скоростта с 10%**, **второ време след което намалява скоростта с 5%** и **времето до края** на пътуването. За да намерите разстоянието трябва да **превърнете минутите в часове \( 70 мин = 1.1666 часа\).**

TODO: картинка

### Входни данни

От конзолата се четат **4 реда**:

**Ред 1. Първоначалната скорост в км/ч**– **цяло число** в интервала **\[1 ... 300\]**

**Ред 2. Първото време в минути**– **цяло число** в интервала **\[1...1000\]**

**Ред 3. Второто време в минути**– **цяло число** в интервала **\[1...1000\]**

**Ред 4. Третото време в минути**– **цяло число** в интервала **\[1...1000\]**

### Изходни данни

Да се отпечата на конзолата **едно число**: **изминатите километри**. **Форматирано до вторият знак след десетичната запетая.**

### Примерен вход и изход

TO DO

### Насоки и подсказки

Верятно е подобно условие да изглежда на пръв поглед объркващо и непълно, което придава допълнителна сложност на една лесна задача. Нека разделим заданието на няколко под-задачи и да се опитаме да решим всяка една от тях, което несъмнено ще ни отведе и до крайния резултат:

* Нека първата под-задача бъде да прочетем входните данни, които потребителя въвежда и да ги запазим в подходящи променливи.
* Изпълнение на основната програмна логика, което в нашия случай се свежда до прости пресмятания с данните, които вече имаме.
* Пресмятане и оформяне на крайния резултат.

Съществената част от програмната логика се изразява в това да пресметнем какво ще бъде изминатото разстояние след всички промени в скоростта. Тъй като по време на изпълнението на програмата част от данните, с които разполагаме се променят бихме могли да разделим програмния код на няколко мисловни части:

* Пресмятане на изминатото разстояние с първоначална скорост.
* Промяна на скоростта и пресмятане на изминатото разстояние.
* Последна промяна на скоростта и пресмятане.
* Сумиране.

За извършване на пресмятанията избираме да използваме тип **decimal**.

![](/assets/exam-prep-2-images/exam-prep-distance-1.png)

Повече за различните типове данни в езика C\# може да прочетете тук:

[http://www.introprogramming.info/intro-csharp-book/read-online/glava2-primitivni-tipove-i-promenlivi/\#\_Toc298863935](http://www.introprogramming.info/intro-csharp-book/read-online/glava2-primitivni-tipove-i-promenlivi/#_Toc298863935)

Изминалото време \(в часове\) пресмятаме като разделим времето на скоростта. Изминатото разстяние намираме като умножим началната скорост с изминалото време \(в часове\). След това променяме скоростта като я увеличаваме с 10% по условие. Пресмятането на процентите както и следващите изминати разстояния извършваме по следния начин:

* Интервалът от време (в часове) намираме като разделим зададения интервал в минути на минутите, които се съдържат в един час (60).
* Изминатото разстояние намираме като умножим интервалът (в часове) и скоростта, която получихме след увеличението.
* Следващата стъпка е да намалим скоростта с 5% както е зададено по условие.
* Намираме оставащото разстояние по описания начин в точки 1 и 2.

До този момент успяхме да изпълним две от най-важните под-задачи, а именно приемането на данните и тяхната обработка. Остава ни само едно – да пресметнем крайния резултат. Тъй като по условие се изисква той да бъде форматиран до 2 знака след десетичната запетая можем да го направим по следния начин:

![](/assets/exam-prep-2-images/exam-prep-distance-2.png)

В случай, че сте работили правилно и изпълните програмата с входните данни от условието на задачата ще се уверите, че тя работи коректно.

### Тестване в Judge системата


## Задача 2. Смяна на плочки

Хараламби има **събрани пари** с които иска да **смени плочките на пода в банята**. Като **подът е правоъгълник**, а **плочките са триъгълни**. Напишете **програма**, която да **пресмята дали събраните пари ще му стигнат**. **От конзолата се чете широчината и дължината на пода**, както и **едната страна на триъгълника с височината към нея**. Трябва да **пресметнете колко плочки са нужни,** за да се покрие пода. **Броят** на плочките **трябва да се закръгли към по-високо цяло число** и **да се прибавят още 5 броя** за фира. **От конзолата се четат** още – **цената на плочка** и **сумата за работата** на майстор.

TODO: картинка

### Входни данни

От конзолата се четат **7 реда**:

**Ред 1. Събраните пари**

**Ред 2. Широчината на пода**

**Ред 3. Дължината на пода**

**Ред 4. Страната на триъгълника**

**Ред 5. Височината на триъгълника**

**Ред 6. Цената на една плочка**

**Ред 7. Сумата за майстора**

**Всички** числа са **реални числа в интервала \[0.00 ... 5000.00\]**

### Изходни данни

На конзолата трябва да се отпечата на **един ред**:

Ако парите **са достатъчно**:

“**{Оставащите пари} lv left.**”

Ако парите **НЕ СА достатъчно**:

“**You'll need{Недостигащите пари} lv more.**”

Резултатът трябва да е **форматиран до вторият знак** след десетичната запетая.

### Примерен вход и изход

TO DO

### Насоки и подсказки

Следващата задача изисква от нашата програма да приема повече входни данни и извърши по-голям брой изчисления, въпреки че решението е идентично. Приемането на данните от потребителя извършваме по добре познатия ни начин. Обърнете внимание, че в раздел „Вход“ на условието е упоменато че всички входни данни ще бъдат реални числа и поради тази причина бихме използвали тип **decimal**.

След като вече разполагаме с всичко необходимо, за да изпълним програмната логика можем да пристъпим към следващата част. Как бихме могли да изчислим какъв е необходимия брой плочки, които ще бъдат достатъчни за покритието на целия под? Условието, че плочките има триъгълна форма би могло да довече до объркване, но напрактика задачата се свежда до съвсем прости изчисления. Бихме могли да пресметнем каква е общата площ на пода по формулата за намиране на площ на правоъгълник, както и каква е площта на една плочка по съответната формула за триъгълник.

За да пресметнем какъв брой плочки са необходими разделяме площта на пода на площта на една плочка \(като не забравяме да прибавим 5 броя плочки както е по условие\).

Обърнете внимание, че в условието е упоменато да закръглим броя на плочките получен от делението до по-високо цяло число, след което да прибавим 5. Потърсете повече информация за дефинираната в езика C# функция **Math.Ceiling()** 

До крайния резултат можем да стигнем като пресметнем общата сума, която е необходима, за да бъде покрит целия под като съберем цената на плочките с цената за майстора, която имаме от входните данни. Можем да се досетим, че общия разход за плочките можем да получим като умножим броя плочки по цената за плочка. Дали сумата, с която разполагаме ще бъде достатъчна разбираме като сравним събраните до момента пари (от входните данни) и общите разходи.

### Тестване в Judge системата


## Задача 3. Магазин за цветя

Магазин за цветя предлага **3 вида цветя**: **хризантеми**, **рози** и **лалета**. **Цените зависят от сезона**.
Впразнични дни цените на всички цветя се **увеличават с 15%.** Предлагат се следните **отстъпки**:

За закупени **повече от 7 лалета през прoлетта** – **5% от цената на целият букет**.

За закупени **10 или повече** рози **през зимата** – **10% от цената на целият букет**.

За закупени **повече от 20** цветя **общо през всички сезони** – **20% от цената на целият букет**.

**Отстъпките се правят по така написания ред и могат да се наслагват! Всички отстъпки важат след оскъпяването за празничен ден!**

Цената за аранжиране на букета **винаги** е **2лв.** Напишете програма, която изчислява **цената за един букет.**

TODO: картинка

### Входни данни

Входът се чете от **конзолата** и съдържа **точно 5 реда**:

На **първия** ред е **броят на закупените хризантеми** – **цяло число в интервала \[0 ... 200\]**

На **втория** ред е **броят на закупените рози** – **цяло число в интервала \[0 ... 200\]**

На **третия** ред е **броят на закупените лалета** – **цяло число в интервала \[0 ... 200\]**

На **четвъртия** ред е посочен **сезона** – **\[Spring,Summer,Аutumn,Winter\]**

На **петия** ред е посочено **дали денят е празник** – **\[Y– да /N- не\]**

### Изходни данни

Да се **отпечата** на конзолата **1 число – цената на цветята**, **форматирана до вторият знак след дес.запетая**.

### Примерен вход и изход

TO DO

### Насоки и подсказки

След като прочитаме внимателно условието разбираме, че отново се налага да изавършваме прости пресмятания, но за разлика този път ще са необходими и повече логически проверки. Следва да обърнем повече внимание на това в какъв момент се извършват промените по крайната цена, за да можем правилно да изградим логиката на нашата програма. Отново удебеленият текст ни дава достатъчно насоки как да подходим. Като за начало отделяме вече дефинираните стойности в променливи както направихме и в предишните задачи:

![](/assets/exam-prep-2-images/exam-prep-flowers-1.png)

Правим същото и за останалите вече-дефинирани стойности:

![](/assets/exam-prep-2-images/exam-prep-flowers-2.png)

Следващата ни под-задача е да прочетем правилно входните данни от конзолата. Подхождаме по добре познатия ни вече начин, но този път комбинираме две отделни функции – една за прочитане на ред от конзолата и друга за преобразуването му в числен тип данни:

![](/assets/exam-prep-2-images/exam-prep-flowers-3.png)

Нека помислим кой е най-подходящия начин да структурираме нашата програмна логика. От условието става ясно, че пътя на програмата се разделя основно на две части: Пролет/Лято и Есен/Зима. Разделението правим с условна конструкция като преди това заделяме променливи за цените на отделните цветя както и крайния резултат.

![](/assets/exam-prep-2-images/exam-prep-flowers-4.png)

Остава ни да извършим няколко проверки относно намаленията на различните видове цветя в зависимост от сезона и да модифицираме крайния резултат. 

### Тестване в Judge системата


## Задача 4. Оценки

Напишете програма, която да **пресмята статистика на оценки** от изпит. В началото програмата получава **броят на студентите** явили се на изпита и за **всеки студент неговата оценка**. На края програмата трябва да **изпечата процента на студенти** с оценка между **2.00 и 2.99**, между **3.00 и 3.99**, между **4.00 и 4.99**, **5.00 или повече**. Също така и **средният успех** на изпита.

TODO: картинка

### Входни данни

От конзолата се четат **поредица от числа, всяко на отделен ред**:

* На **първия ред** – **броя на студентите явили се на изпит** – **цяло число в интервала \[1...1000\]**
* За **всеки един студент** на отделен ред – **оценката от изпита** – **реално число в интервала \[2.00...6.00\]**

### Изходни данни

Да се отпечатат на конзолата **5 реда**, които съдържат следната информация:

**Ред 1 -"Top students: {процент студенти с успех 5.00 или повече}%"**

**Ред 2 -"Between 4.00 and 4.99: {между 4.00 и 4.99 включително}%"**

**Ред 3 -"Between 3.00 and 3.99: {между 3.00 и 3.99 включително}%"**

**Ред 4 -"Fail: {по-малко от 3.00}%"**

**Ред 5 -"Average: {среден успех}"**

### Примерен вход и изход

TO DO

### Насоки и подсказки

Подобно на предходните задачи входните данни ще четем от конзолата. Разликата тук, е че тъй като имаме четене от конзолата различен брой пъти се налага да запазим данните в подходяща структура. Такива структури са масив и списък, но тъй като знаеам броя на данните е подходящо да използваме масив. Това постигаме като след първото прочитаме създадем масив със дължина равна на числото, което потребителя въведе за брой студенти, след което обхождаме масива и на всяка итерация на цъкъла отново четем от конзолата и резултата записваме на съответната позиция.

![](/assets/exam-prep-2-images/exam-prep-grades-1.png)

За изпълнението на основната програмна логика бихме могли да разделим задачата на няколко под-проблема, решаването на които ще ни отведе и до крайния резултат.
Заделяне на променливи, къде ще пазим броя на студентите за всяка група: слаби резултати (до 2.99), резултати от 3 до 3.99, от 4 до 4.99 и оценки над 5. Ще ни е необходима и ще една променлива, в която да пазим сумата на всички оценки.

![](/assets/exam-prep-2-images/exam-prep-grades-2.png)

Обхождаме масива и на всяка итерация проверяваме каква е стойността на елемента. С поред зависимост от тази стойност увеличаваме броя на студентите в съответната група с **1** като не забравяме да увеличим и общата сума на оценките, която също следим.

![](/assets/exam-prep-2-images/exam-prep-grades-3.png)

Какъв процент заема дадена група студенти от общия брой можем да пресметнем като умножим броя на студенти от съответната група по **100** и след това разделим на **10**. **Обърнете внимание с какъв числен тип данни работите при извършване на тези пресмятания.**

Крайния резултат оформяме по добре познатия ни начин до второ число след десетичната запетая.

### Тестване в Judge системата


## Задача 5. Коледна шапка

Да се напише програма, която прочита от конзолата **цяло числоN**и чертае **коледна шапка** с ширина **4 \*n+ 1 колони**и височина **2 \*n + 5реда**като в примерите по-долу.

TODO: картинка

### Входни данни

Входът се чете от конзолата – едно **цяло число N** в интервала \[**3**…**100**\].

### Изходни данни

Да се отпечата на конзолата **коледна шапка**, точно както в примерите.

### Примерен вход и изход

### Насоки и подсказки

При задачите за чертаене с конзолата най-често потребителя въвежда едно цяло число, което играе ролята на обща големина на фигурката, която трябва да начертаем.
Тъй като в условието е упоменато как се изчисляват общата дължина и широчина на фигурката можем да ги използваме за отправни точки. От примерите ясно се вижда, че без значение какви са входните данни винаги имаме първи два реда, които са с почти идентично съдържание.

![](/assets/exam-prep-2-images/exam-prep-hat-1.png)

Забелязваме също така, че последните три реда винаги присъстват, два от които са напълно еднакви.

![](/assets/exam-prep-2-images/exam-prep-hat-2.png)

От тези наши наблюдения можем да изведем формулата за височина на променливата част на коледната шапка. Използваме зададената по условие формула за общата височина като изваждаме големината на непроменливата част. Получаваме **(2 * n + 5) – 5** или **2 * n**.

За начертаването на динамичната или променлива част от фигурката ще използваме цикъл. Размерът на цикъла ще бъде от **0** до широчината, която имаме по условие, а именно **4 * n + 1**. Тъй-като тази формула ще използваме на няколко места в кода е добра практика да я изнесем в отделна променлива. Преди изпълнението на цикъла би следвало да заделим променливи за броя на отделните символи, които участват в динамичната част: точки и тирета. Чрез изучаване на примерите можем да изведем формули и за стартовите стойности на тези променливи. Първоначално тиретата са **0**, но броя на точките ясно се вижда, че можем да получим като от общата широчина извадим **3** (броя символи, които изграждат върха на коледната шапка) и след това разделим на две, тъй като броя точки от двете страни на шапката е еднакъв.

![](/assets/exam-prep-2-images/exam-prep-hat-3.png)

Остава да изпълним тялото на цикъла като след всяко начертаване намалим броя на точки с **1**, а тиретата увеличим с **1**. Да не забравяме да начертаем и по една звездичка между тях.
Последователността на чертаене в тялото на цикъла е:

*	Символен низ от точки.
*	Звезда,
*	Символен низ от тирета.
*	Звезда.
*	Символен низ от тирета.
*	Звезда.
*	Символен низ от точки.

В случай, че сме работили правилно получаваме фигурки идентични на тези от примерите.

### Тестване в Judge системата


## Задача 6. Комбинации от букви

Напишете програма, която да **принтира** на конзолата **всички комбинации от 3 букви** в **зададен интервал**, **като се пропускат** комбинациите **съдържащи зададена от конзолата буква**. **Накрая трябва да се изпринтира броят** на **отпечатаните комбинации**.

TODO: картинка

### Входни данни

Входът се чете от **конзолата** и съдържа **точно 3 реда**:

  **Ред 1. Малка буква от английската азбука за начало на интервала – от ‘a’ до ‚z’.**

  **Ред 2. Малка буква от английската азбука за край на интервала – от първата буква до ‚z’.**
  
  **Ред 3. Малка буква от английската азбука – от ‘a’ до ‚z’ – като комбинациите съдържащи тази буквата се пропускат.**

### Изходни данни

Да се отпечатат на **един ред всички комбинации отговарящи на условието плюс броят им разделени с интервал.**

### Примерен вход и изход

### Насоки и подсказки

За последната задача имаме по условие входни данни на **3 реда**, които са представени от по един символ от **ASCII таблицата** (http://www.asciitable.com/). Бихме могли да използваме вече дефинирана функция в езика **C#** като преобразуваме входните данни в тип данни **char** по следния начин:

![](/assets/exam-prep-2-images/exam-prep-letters-1.png)

Нека помислим как бихме могли да стигнем до крайния резултат. В случай, че условието на задачата беше да се изпринтират всички от началния до крайния символ (с пропускане на определна буква) как щяхме да постъпим? 

Най-лесният и удачен начин е да използваме цикъл като преминем през всички символи и принтираме тези, които са различни от буквата, която трябва да пропуснем. Едно от предимствата на езика **C#**, е че имаме възможност да използваме различен тип данни за циклична променлива:

![](/assets/exam-prep-2-images/exam-prep-letters-2.png)

Резултатът от изпълнението на кода е всички букви от **а** до **z** включително принтирани на един ред и разделени с интервал. Това прилича ли Ви на крайния резултат от нашата задача? Трябва да измислим начин, по който да се принтират по **3 символа** както е по условие, вместо по **1**. Изпълнението на програмата много прилича на игрална машина. Там най-често печелите ако успеете да наредите няколко еднакви символа. Да речем, че на машината имате места за три символа. Когато спрете на даден символ на първото място на останалите две места продължават да се изреждат символи от **всички възможни**. В нашия случай **всички възможни** са буквите от началната до крайната зададена от потребителя, а решението на нашата програма и идентично на начина, по който работи игралната машина.

Използваме цикъл който минава през всички символи от началната до крайната буква включително. На всяка итерация на първия цикъл пускаме втори със същите параметри. На всяка итерация на втория цикъл пускаме още един със същите параметри.

![](/assets/exam-prep-2-images/exam-prep-letters-3.png)

Не забравяйте че се изисква от нас да принтираме и **общия брой валидни комбинации**, които сме намерили, както и че те трябва да се принтират на **същия ред разделени с интервал.**

### Тестване в Judge системата


## Какво научихме от тази глава?

В настоящата глава разгледахме задачите от един реален практически изпит, проведен в СофтУни, който съответства на учебния материал от настоящата книга, както и предложихме подход за решаване и конкретни решения, които да използваме като подготовка за бъдещи изпити по основи на програмирането.

